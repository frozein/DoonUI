#include "render.h"
#include "math/matrix.h"
#include "math/vector.h"

#include <stdio.h>
#include <malloc.h>
#include <math.h>
#include <string.h>
#include <GLAD/glad.h>
#include <FreeType/ft2build.h>
#include FT_FREETYPE_H

static bool _DNUI_load_into_buffer(const char* path, char** buffer);
static bool _DNUI_load_shader_program(const char* vertPath, const char* fragPath, GLuint* program);

//--------------------------------------------------------------------------------------------------------------------------------//

static GLuint textProgram;
static GLuint textBuffer;
static GLuint textArray;

static GLuint rectProgram;
static GLuint rectBuffer;
static GLuint rectArray;

static FT_Library freetypeLib;

typedef struct DNUIfont
{
	int textureAtlas;
	DNivec2 atlasSize;

	struct
	{
		float advance;
		float bmpW;
		float bmpH;
		float bmpL;
		float bmpT;
		float offset;
	} glyphInfo[128];
} DNUIfont;

#define DNUI_MAX_FONTS 16
int curFont = 0;
DNUIfont fonts[DNUI_MAX_FONTS];

static DNmat3 projectionMat;

static GLuint testTexture;

//--------------------------------------------------------------------------------------------------------------------------------//

bool DNUI_init(unsigned int windowW, unsigned int windowH)
{
	//load shader programs:
	//---------------------------------
	if(!_DNUI_load_shader_program("shaders/rect.vert", "shaders/rect.frag", &rectProgram))
		return false;
	
	if(!_DNUI_load_shader_program("shaders/text.vert", "shaders/text.frag", &textProgram))
		return false;

	//create rect vertex buffer:
	//---------------------------------
	float quadVertices[] = {
     	 1.0f,  1.0f,
     	 1.0f, -1.0f,
    	-1.0f, -1.0f,
    	-1.0f, -1.0f,
    	 1.0f,  1.0f,
    	-1.0f,  1.0f
	};

	glGenVertexArrays(1, &rectArray);
	glGenBuffers(1, &rectBuffer);

	glBindVertexArray(rectArray);
	glBindBuffer(GL_ARRAY_BUFFER, rectBuffer);
	glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), quadVertices, GL_STATIC_DRAW);

	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 2, (void*)0);
	glEnableVertexAttribArray(0);

	//create text vertex buffer:
	//---------------------------------
	glGenVertexArrays(1, &textArray);
	glGenBuffers(1, &textBuffer);

	glBindVertexArray(textArray);
	glBindBuffer(GL_ARRAY_BUFFER, textBuffer);

	glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 4, (void*)0);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(GLfloat) * 4, (void*)(sizeof(GLfloat) * 2));
	glEnableVertexAttribArray(1);

	//set projection matrix:
	//---------------------------------
	DNUI_set_window_size(windowW, windowH);

	//initialize freetype:
	//---------------------------------
	if(FT_Init_FreeType(&freetypeLib))
	{
		printf("DNUI ERROR - FAILED TO INITIALIZE FREETYPE\n");
		return false;
	}

	//create test texture:
	//---------------------------------
	/*glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

	glGenTextures(1, &testTexture);
	glBindTexture(GL_TEXTURE_2D, testTexture);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, font->glyph->bitmap.width, font->glyph->bitmap.rows, 0, GL_RED, GL_UNSIGNED_BYTE, font->glyph->bitmap.buffer);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);*/

	return true;
}

int DNUI_load_font(const char* path, int size)
{	
	//find new font index:
	//---------------------------------
	int newIndex = curFont;
	for(int i = 0; i < curFont; i++)
		if(fonts[i].textureAtlas < 0)
		{
			newIndex = i;
			break;
		}
	
	if(newIndex == curFont)
	{
		if(curFont >= DNUI_MAX_FONTS)
		{
			printf("DNUI ERROR - MAX FONTS EXCEEDED\n");
			return -1;
		}

		curFont++;
	}

	//load freetype face:
	//---------------------------------
	FT_Face font;
	if(FT_New_Face(freetypeLib, path, 0, &font))
	{
		printf("DNUI ERROR - FAILED TO LOAD FONT \"%s\"\n", path);
		return -1;
	}

	FT_Set_Pixel_Sizes(font, 0, size);

	//compute texture dimensions:
	//---------------------------------
	int w = 0;
	int h = 0;
	for(int i = 32; i < 128; i++)
	{
		if(FT_Load_Char(font, i, FT_LOAD_BITMAP_METRICS_ONLY))
		{
			printf("DNUI ERROR - FAILED TO LOAD CHARACTER \"%c\"", i);
			continue;
		}

		w += font->glyph->bitmap.width;
		if(font->glyph->bitmap.rows > h)
			h = font->glyph->bitmap.rows;
	}

	//create texture:
	//---------------------------------
	GLuint tex;
	glGenTextures(1, &tex);
	glBindTexture(GL_TEXTURE_2D, tex);
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1); //since the bitmaps generated by freetype have an alignment of 1 byte
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RED, w, h, 0, GL_RED, GL_UNSIGNED_BYTE, NULL);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	int x = 0;
	for(int i = 32; i < 128; i++)
	{
		if(FT_Load_Char(font, i, FT_LOAD_RENDER))
		{
			printf("DNUI ERROR - FAILED TO LOAD CHARACTER \"%c\"", i);
			continue;
		}

		//set data:
		fonts[newIndex].glyphInfo[i].advance = font->glyph->advance.x;
		fonts[newIndex].glyphInfo[i].bmpW = font->glyph->bitmap.width;
		fonts[newIndex].glyphInfo[i].bmpH = font->glyph->bitmap.rows;
		fonts[newIndex].glyphInfo[i].bmpL = font->glyph->bitmap_left;
		fonts[newIndex].glyphInfo[i].bmpT = font->glyph->bitmap_top;
		fonts[newIndex].glyphInfo[i].offset = (float)x / w;

		//set texture:
		glTexSubImage2D(GL_TEXTURE_2D, 0, x, 0, font->glyph->bitmap.width, font->glyph->bitmap.rows, GL_RED, GL_UNSIGNED_BYTE, font->glyph->bitmap.buffer);

		//advance:
		x += font->glyph->bitmap.width;
	}

	fonts[newIndex].textureAtlas = tex;
	fonts[newIndex].atlasSize.x = w;
	fonts[newIndex].atlasSize.y = h;

	return newIndex;
}

void DNUI_close()
{
	glDeleteProgram(textProgram);
	glDeleteProgram(rectProgram);
	glDeleteVertexArrays(1, &rectArray);
	FT_Done_FreeType(freetypeLib);
}

void DNUI_set_window_size(unsigned int w, unsigned int h)
{
	//generate new projection matrix:
	//---------------------------------
	projectionMat = DN_MAT3_IDENTITY;
	projectionMat.m[0][0] = 2.0f / w;
	projectionMat.m[1][1] = 2.0f / h;
	projectionMat.m[2][0] = -1.0f;
	projectionMat.m[2][1] = -1.0f;
}

void DNUI_drawrect(DNvec2 center, DNvec2 size, float angle, DNvec4 color, float cornerRad)
{
	DNmat3 model = DN_mat3_translate(DN_MAT3_IDENTITY, (DNvec2){center.x, center.y});
	model = DN_mat3_rotate(model, angle);
	model = DN_mat3_scale(model, (DNvec2){size.x * 0.5f, size.y * 0.5f});

	model = DN_mat3_mult(projectionMat, model);

	glUseProgram(rectProgram);

	glUniformMatrix3fv(glGetUniformLocation(rectProgram, "model"), 1, GL_FALSE, (GLfloat*)&model);
	glUniform4fv(glGetUniformLocation(rectProgram, "color"), 1, (GLfloat*)&color);
	glUniform2fv(glGetUniformLocation(rectProgram, "size"), 1, (GLfloat*)&size);
	glUniform1f(glGetUniformLocation(rectProgram, "cornerRad"), cornerRad);
	glUniform1ui(glGetUniformLocation(rectProgram, "useTex"), false);
	glUniform1i(glGetUniformLocation(rectProgram, "tex"), 0);

	glBindVertexArray(rectArray);
	glDrawArrays(GL_TRIANGLES, 0, 6);
}

void DNUI_drawstring(const char* text, unsigned int font, DNvec2 pos, DNvec2 scale)
{
	//create vertex array:
	//---------------------------------
	struct Vertex
	{
		GLfloat x;
		GLfloat y;
		GLfloat texX;
		GLfloat texY;
	}* vertices;

	int numVertices = 6 * strlen(text);
	vertices = malloc(4 * sizeof(GLfloat) * numVertices);

	//generate vertex data:
	//---------------------------------
	int i = 0;
	char* c = (char*)text;
	while(i < numVertices)
	{
		float offset = fonts[font].glyphInfo[*c].offset;
		float bmpW = fonts[font].glyphInfo[*c].bmpW;
		float bmpH = fonts[font].glyphInfo[*c].bmpH;

		float x =  pos.x + fonts[font].glyphInfo[*c].bmpL * scale.x;
		float y = -pos.y - fonts[font].glyphInfo[*c].bmpT * scale.y;
		float w = fonts[font].glyphInfo[*c].bmpW * scale.x;
		float h = fonts[font].glyphInfo[*c].bmpH * scale.y;

		pos.x += fonts[font].glyphInfo[*c].advance;

		if(w <= 0.0 || h <= 0.0)
			continue;

		vertices[i++] = (struct Vertex){x	 , -y	 , offset								  , 0.0							  };
		vertices[i++] = (struct Vertex){x + w, -y	 , offset + bmpW / fonts[font].atlasSize.x, 0.0							  };
		vertices[i++] = (struct Vertex){x	 , -y - h, offset								  , bmpH / fonts[font].atlasSize.y};
		vertices[i++] = (struct Vertex){x + w, -y	 , offset + bmpW / fonts[font].atlasSize.x, 0.0							  };
		vertices[i++] = (struct Vertex){x	 , -y - h, offset								  , bmpH / fonts[font].atlasSize.y};
		vertices[i++] = (struct Vertex){x + w, -y - h, offset + bmpW / fonts[font].atlasSize.x, bmpH / fonts[font].atlasSize.y};

		c++;
	}

	//send to GPU:
	//---------------------------------
	glBindBuffer(GL_ARRAY_BUFFER, textBuffer);
	glBufferData(GL_ARRAY_BUFFER, 4 * sizeof(GLfloat) * numVertices, vertices, GL_DYNAMIC_DRAW);

	glUseProgram(textProgram);
	glUniform4f(glGetUniformLocation(rectProgram, "color"), 1.0, 1.0, 1.0, 0.0);
	glUniformMatrix3fv(glGetUniformLocation(rectProgram, "projection"), 1, GL_FALSE, (GLfloat*)&projectionMat);
	glUniform1i(glGetUniformLocation(rectProgram, "textureAtlas"), 0);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, fonts[font].textureAtlas);

	glBindVertexArray(textArray);
	glDrawArrays(GL_TRIANGLES, 0, numVertices);

	free(vertices);
}

static bool _DNUI_load_into_buffer(const char* path, char** buffer)
{
	*buffer = 0;
	long length;
	FILE* file = fopen(path, "rb");

	if(file)
	{
		bool result = false;

		fseek(file, 0, SEEK_END);
		length = ftell(file);
		fseek(file, 0, SEEK_SET);
		*buffer = (char*)calloc(1, length + 1);

		if(*buffer)
		{
			if(fread(*buffer, length, 1, file) == 1)
				result = true;
			else
			{
				printf("DNUI ERROR - COULD NOT READ FROM FILE %s\n", path);
				result = false;
				free(*buffer);
			}
		}
		else
			printf("DNUI ERROR - COULD NOT ALLOCATE MEMORY FOR SHADER SOURCE CODE");

		fclose(file);
		return result;
	}
	else
	{
		printf("DNUI ERROR - COULD NOT OPEN FILE %s\n", path);
		return false;
	}
}

bool _DNUI_load_shader_program(const char* vertPath, const char* fragPath, GLuint* program)
{
	//load from files:
	char* vertexSource = 0;
	if(!_DNUI_load_into_buffer(vertPath, &vertexSource))
		return false;

	char* fragmentSource = 0;
	if(!_DNUI_load_into_buffer(fragPath, &fragmentSource))
		return false;

	unsigned int vertex, fragment;
	int success;
	char infoLog[512];

	//compile vertex shader:
	vertex = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertex, 1, &vertexSource, NULL);
	glCompileShader(vertex);
	glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
	if(!success)
	{
		glGetShaderInfoLog(vertex, 512, NULL, infoLog);
		printf("vertex.vert - %s\n DNUI ERROR - FAILED TO COMPILE VERTEX SHADER\n", infoLog);
		return false;
	}

	//compile fragment shader:
	fragment = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragment, 1, &fragmentSource, NULL);
	glCompileShader(fragment);
	glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
	if(!success)
	{
		glGetShaderInfoLog(fragment, 512, NULL, infoLog);
		printf("fragment.frag - %s\n DNUI ERROR - FAILED TO COMPILE FRAGMENT SHADER", infoLog);
		return false;
	}

	//link shaders:
	unsigned int prog = glCreateProgram();
	glAttachShader(prog, vertex);
	glAttachShader(prog, fragment);
	glLinkProgram(prog);
	glGetProgramiv(prog, GL_LINK_STATUS, &success);
	if(!success)
	{
		glGetProgramInfoLog(prog, 512, NULL, infoLog);
		printf("%s\n DNUI ERROR - FAILED TO LINK SHADER PROGRAM", infoLog);
		return false;
	}

	*program = prog;

	//delete shaders:
	glDeleteShader(vertex);
	glDeleteShader(fragment);

	//free memory:
	free(vertexSource);
	free(fragmentSource);

	return true;
}